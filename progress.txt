## Codebase Patterns
- PyQt6 override methods must use noqa comments to suppress naming convention errors when parent classes use camelCase
- When converting methods to static, update all call sites to use ClassName.method_name() instead of self.method_name()
- Magic numbers should be extracted to module-level constants for maintainability
- Complex methods can be refactored by extracting helper methods to reduce nesting and cyclomatic complexity
- Use keyword arguments (value=...) for boolean signal emissions to comply with FBT003 rules
- Frozen dataclasses with datetime fields need __post_init__ to handle tzinfo normalization
- New modules need __init__.py files even if empty to be recognized as Python packages
- PyObjC libraries (AppKit, Quartz, Cocoa) don't have type stubs - use `# type: ignore[import-untyped]` and `typing.cast()` for basedpyright
- Always add `super().__init__()` in __init__ methods to avoid reportMissingSuperCall errors
- Use datetime.UTC instead of datetime.timezone.utc (ruff UP017 auto-fix)

---

## 2026-01-11 - US-001, US-002, US-003, US-004, US-005
Thread: Local Development

### Summary
All ruff linting errors have been resolved. The project went from 33 linting errors to 0 errors.

### US-001 - Fix calendar_widget.py linting errors
Files changed:
- src/activity_beacon/viewer/calendar_widget.py

Changes:
- Added type annotation for file_system_reader parameter (FileSystemReader)
- Added type annotation for rect parameter (QRect)
- Renamed import to lowercase date in calendar_widget.py imports
- Used noqa comment to suppress N802 error for paintCell (inherited method override)
- Changed unused year and month parameters to _year and _month to comply with ARG002

### US-002 - Fix filesystem_reader.py linting errors
Files changed:
- src/activity_beacon/viewer/filesystem_reader.py

Changes:
- Renamed Date import to lowercase date
- Extracted magic numbers (4, 2) to named constants: YEAR_DIGITS, MONTH_DIGITS, DAY_DIGITS
- Refactored get_available_dates to reduce nesting and complexity:
  - Extracted _process_year_dir helper method
  - Extracted _process_month_dir helper method (static)
  - Extracted _process_day_dir helper method (static)
- Reduced nesting from 5 levels to 2 levels by using list.extend() instead of nested loops
- Reduced cyclomatic complexity from 14 to well below threshold

### US-003 - Fix main.py linting errors
Files changed:
- src/activity_beacon/viewer/main.py

Changes:
- Added type annotation for event parameter in resizeEvent (QResizeEvent)
- Used noqa comment to suppress N802 error for resizeEvent (inherited method override)
- Refactored on_date_selected method to reduce cyclomatic complexity:
  - Extracted _handle_no_video_available helper method
  - Extracted _load_video_and_data helper method
  - Extracted _load_window_data helper method
  - Extracted _get_video_start_datetime as static method
  - Extracted _setup_duration_changed_handler helper method
- Reduced cyclomatic complexity from 12 to below threshold
- Moved date type import to TYPE_CHECKING block
- Added type annotations for py_date parameters (date_type alias)

### US-004 - Fix video_player.py linting errors
Files changed:
- src/activity_beacon/viewer/video_player.py

Changes:
- Extracted magic number 2 to MIN_ERROR_ARGS constant
- Refactored __init__ to reduce statement count:
  - Extracted _setup_widgets helper method
  - Extracted _setup_layout helper method
  - Extracted _setup_signals helper method
- Converted _fmt_ms method to static method
- Updated all blockSignals calls to use keyword arguments (block=True/False)
- Updated all loading_changed.emit calls to use keyword arguments (value=True/False)
- Added type annotation for *args parameter in _on_error

### US-005 - Fix window_data_parser.py linting errors
Files changed:
- src/activity_beacon/viewer/window_data_parser.py
- src/activity_beacon/viewer/window_data_timeline.py

Changes in window_data_parser.py:
- Reduced nesting in parse_file by extracting file reading to _read_entries_from_file (static)
- Converted parse_line method to static method
- Converted match_timestamp_to_video_position to static method
- Added PLR6301 noqa comment on parse_file (keeps instance method for compatibility)

Changes in window_data_timeline.py:
- Updated _recompute_positions to call WindowDataParser.match_timestamp_to_video_position as static method
- Removed unnecessary parser instance creation

### Quality Results
- Ruff errors: 33 â†’ 0 (100% resolved)
- All unit tests still pass
- Code functionality maintained
- All changes follow existing code patterns

### Learnings for Future Iterations
- PyQt6 methods that override parent class methods with camelCase names should use noqa comments rather than attempting renaming
- When making methods static, grep the entire codebase for all call sites before committing
- The pattern of extracting helper methods is effective for reducing complexity and nesting in large methods
- Use keyword arguments consistently for PyQt signals when booleans are involved
- Magic numbers should always be extracted to named constants at module level
- Pre-commit hooks include basedpyright which may have pre-existing type checking errors unrelated to ruff linting

---

## 2026-01-11 - US-002
Thread: https://ampcode.com/threads/local-development

### Summary
Implemented ScreenshotCapture class with monitor enumeration and individual monitor capture using mss library.

### Files Changed
- src/activity_beacon/screenshot/capture.py (new)
- src/activity_beacon/screenshot/__init__.py (modified - exports)
- tests/test_screenshot_capture.py (new)

### Changes
- Created MonitorInfo dataclass with geometry and resolution properties
- Implemented ScreenshotCapture class with:
  - enumerate_monitors() - detects all monitors with primary identification
  - get_monitor_count() - returns number of physical monitors
  - get_monitor_info() - returns MonitorInfo for specific monitor
  - capture_monitor() - captures screenshot from specific monitor
  - capture_all_monitors() - captures screenshots from all monitors
  - capture_to_path() - saves screenshot to file with format support
  - Context manager support (enter/exit)
- Added comprehensive tests with mocking for mss library (14 tests passing)

### Quality Results
- basedpyright: 0 errors
- ruff: All checks passed
- pytest: 14 tests passed (100%)
- screenshot/capture.py coverage: 95.50%

### Learnings for Future Iterations
- mss.monitors[0] is a virtual monitor representing all combined monitors - skip it
- mss library doesn't have complete type stubs; use MSSBase from mss.base for typing
- Primary monitor detection: monitor with x=0, y=0 is primary
- Mock mss.mss with patch('mss.mss') and set .monitors attribute on the return value
- For nested with statements in tests, use ExitStack from contextlib for cleaner code
- Image.frombytes needs raw mode "BGRX" for mss screenshots on macOS

**Learnings for future iterations:**
  - mss.monitors[0] is virtual combined monitor - skip in enumerate loop
  - Use MSSBase type from mss.base for mss instance typing when needed
  - patch('mss.mss') works best for mocking mss in tests
  - ExitStack is useful for combining multiple context managers in tests
  - mss screenshots use BGRA byte order, convert with "BGRX" raw mode

---

## 2026-01-11 - US-003
Thread: Local Development

### Summary
Implemented ImageProcessor class for multi-monitor screenshot stitching with scaling, aspect ratio preservation, and horizontal stitching.

### Files Changed
- src/activity_beacon/screenshot/image_processor.py (new)
- src/activity_beacon/screenshot/__init__.py (modified - exports)
- tests/test_image_processor.py (new)

### Changes
- Created ImageProcessor class with:
  - `stitch_horizontally()` - stitches multiple monitor images into composite
  - `stitch_with_metadata()` - returns composite with metadata
  - `_scale_image()` - scales images using LANCZOS resampling
  - `_find_target_resolution()` - finds highest resolution monitor
  - `_calculate_scale_factor()` - maintains aspect ratio during scaling
  - `last_error_msg` - error tracking attribute
- Images are scaled to match the highest resolution monitor's dimensions
- Aspect ratio is preserved during scaling using min(width_ratio, height_ratio)
- Horizontal stitching places monitors side-by-side in sorted order
- Added 14 tests covering edge cases and multi-monitor configurations

### Quality Results
- basedpyright: 0 errors
- ruff: All checks passed
- pytest: 14 tests passed (100%)
- image_processor.py coverage: 90.24%

### Learnings for Future Iterations
- basedpyright doesn't allow `Any` type - use `object` or `Mapping[str, object]` instead
- Image.new() and Image.paste() require real PIL Images, not MagicMock objects
- Tests using real PIL Images are more reliable than mocking Image operations
- Use `# type: ignore[reportMissingSuperCall]` for simple classes without parent
- Ruff F841 for unused variables - use `_` prefix for intentionally unused values
- `@staticmethod` decorator for helper methods that don't use `self`
- Use `Mapping` instead of `dict` for function parameters to allow more flexibility

**Learnings for future iterations:**
  - Use `object` instead of `Any` for type annotations to satisfy basedpyright
  - Use real PIL Images in tests instead of MagicMock for Image operations
  - `@staticmethod` for methods that don't use `self`
  - Use `Mapping` type for flexible dict-like parameters
  - Add `# type: ignore[reportMissingSuperCall]` for classes without parent class

---

## 2026-01-11 - US-004
Thread: Local Development

### Summary
Implemented ChangeDetector class for pixel-level analysis to detect changes between consecutive screenshots using numpy-based pixel comparison.

### Files Changed
- src/activity_beacon/screenshot/change_detector.py (new)
- tests/test_change_detector.py (new)

### Changes
- Created ChangeDetector class with:
  - `has_changed()` - detects if current image differs from previous beyond threshold
  - `calculate_difference_percentage()` - calculates percentage of changed pixels
  - Configurable threshold (default: 10) for pixel difference sensitivity
  - Uses numpy arrays for efficient pixel-level comparison
  - Supports composite (stitched) images
  - Returns True on first capture (no previous image)
  - Returns True on image size mismatch
  - Error handling with last_error_msg attribute
- Implemented with numpy int16 conversion to avoid overflow in difference calculation
- Uses np.max() to find maximum pixel difference across all channels
- Added 20 comprehensive tests covering:
  - Threshold behavior (below, at boundary, above)
  - Edge cases (no previous image, size mismatch, single pixel change)
  - Difference percentage calculation
  - Error handling
  - Different color channel detection
  - Gradient and composite image support

### Quality Results
- basedpyright: 0 errors
- ruff: All checks passed
- pytest: 20 tests passed (100%)
- change_detector.py coverage: 85.45%

### Learnings for Future Iterations
- NumPy types require careful handling in basedpyright - use `# type: ignore[reportAny]` for np.max() return values
- Convert images to int16 before subtraction to avoid uint8 overflow
- Use specific exception types (ValueError, TypeError, AttributeError) instead of bare Exception
- On error in has_changed(), return True to avoid missing captures (fail-safe behavior)
- The `# type: ignore[no-untyped-def]` is needed for __init__ methods in simple classes
- NumPy comparison operations return boolean ndarray which needs conversion to Python bool

**Learnings for future iterations:**
  - Use `# type: ignore[reportAny]` for numpy type inference issues
  - Convert to int16 before pixel difference to prevent uint8 overflow
  - Avoid bare Exception - use specific exception types
  - Fail-safe pattern: return True on errors to avoid missing captures
  - NumPy max() returns numpy types that need explicit int() conversion for type safety

---

## 2026-01-11 - US-005
Thread: Local Development

### Summary
Implemented FocusTracker class for active application detection using AppKit.NSWorkspace. The class tracks the currently focused application, its process ID, and handles edge cases gracefully.

### Files Changed
- src/activity_beacon/window_tracking/focus_tracker.py (new)
- tests/test_focus_tracker.py (new)
- prd.json (updated US-005 passes: true)

### Changes
- Created FocusTracker class with:
  - `get_focused_application()` - returns FocusedAppData with app name, PID, window name, and UTC timestamp
  - Uses AppKit.NSWorkspace for macOS application detection
  - Returns placeholder values ("Unknown", pid=0) when no active app is detected
  - Handles missing or invalid window states gracefully
  - Window name returns None (NSWorkspace doesn't provide window titles directly)
  - Uses `# type: ignore[import-untyped]` for AppKit import (no type stubs available)
  - Uses `typing.cast()` to explicitly type PyObjC method returns for basedpyright
  - Added `super().__init__()` call to satisfy reportMissingSuperCall
- Added comprehensive tests:
  - Initialization test
  - Return type validation
  - Valid app name and PID checks
  - UTC timezone verification
  - Timestamp recency validation
  - Consistency checks for consecutive calls
  - Window name handling (expects None)
- All 8 tests pass successfully

### Quality Results
- basedpyright: 0 errors (for focus_tracker.py and test file)
- ruff: All checks passed
- pytest: 8 tests passed (100%)
- focus_tracker.py coverage: 90.48%

### Learnings for Future Iterations
- PyObjC (AppKit, Quartz, Cocoa) doesn't have type stubs - use `# type: ignore[import-untyped]`
- Use `typing.cast()` to explicitly type PyObjC method returns for basedpyright strict mode
- Use `# type: ignore[no-untyped-call]` for PyObjC method calls to suppress unknown type errors
- NSWorkspace.sharedWorkspace() returns shared workspace instance
- frontmostApplication() returns the currently active application
- localizedName() returns the user-facing application name
- processIdentifier() returns the PID of the application
- NSWorkspace API doesn't provide window titles - need Quartz.CGWindowListCopyWindowInfo for that (WindowEnumerator)
- Always add `super().__init__()` in __init__ methods to avoid reportMissingSuperCall errors
- Use datetime.UTC instead of datetime.timezone.utc (ruff UP017 auto-fix)

---

## 2026-01-11 - US-006
Thread: Local Development

### Summary
Implemented WindowEnumerator class for complete window metadata collection using Quartz.CGWindowListCopyWindowInfo.

### Files Changed
- src/activity_beacon/window_tracking/window_enumerator.py (new)
- src/activity_beacon/window_tracking/__init__.py (modified - exports)
- tests/test_window_enumerator.py (new)
- prd.json (updated US-006 passes: true)

### Changes
- Created WindowEnumerator class with:
  - `enumerate_windows()` - collects information about all visible windows
  - Filters for layer 0 (normal windows) and excludes desktop elements
  - Extracts application names, window names, PIDs, and geometry (screen rect)
  - Identifies focused windows based on PID
- Optimized by caching Quartz constant keys as class attributes
- Handled basedpyright strict mode by using `cast`, `Mapping`, and `# type: ignore[attr-defined]`
- Added 4 comprehensive tests with Quartz mocking

### Quality Results
- basedpyright: 0 errors for window_enumerator.py (Total project errors reduced)
- ruff: All checks passed
- pytest: 67 tests passed (including 4 new tests)
- window_enumerator.py coverage: 100%

### Learnings for Future Iterations
- PyObjC constants (Quartz.kCG...) often require `# type: ignore[attr-defined]` in basedpyright strict mode even if the module is ignored during import
- Use `Mapping[str, object]` instead of `dict` or `Any` for window data dictionaries to satisfy basedpyright
- Caching Quartz keys as class constants helps reduce local variable count and repetitive casting
- `Quartz.kCGWindowListOptionOnScreenOnly | Quartz.kCGWindowListExcludeDesktopElements` is the standard combination for getting visible user windows
- Layer 0 is where normal application windows reside on macOS
